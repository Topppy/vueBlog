(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{46:function(e,r,s){"use strict";s.r(r);var a=s(0),n=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"学习redux之compose"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#学习redux之compose","aria-hidden":"true"}},[e._v("#")]),e._v(" 学习redux之compose")]),s("p",[e._v("在3.7.1版本的compose中，代码更优美了，也更易于理解，源码如下，")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("export default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n")])]),s("p",[e._v("很简洁的一个compose函数，两句边界条件的判断，只有一句是真正的功能代码。")]),s("p",[e._v("首先"),s("code",[e._v("...funcs")]),e._v("是使用es6的rest参数，向compose传递的任意数量的参数都被放在数组funcs中。而接下来，使用了数组的方法"),s("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce",target:"_blank",rel:"noopener noreferrer"}},[e._v("reduce")]),e._v("，")]),s("blockquote",[s("p",[e._v("reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值")])]),s("p",[e._v("这里，我一开始是迷惑的，reduce不是从左到右遍历的吗？而compose是要按照从右到左的顺序组合函数的啊  -> "),s("code",[e._v("compose(f, g) = f(g(args))")]),e._v("，从左到右遍历如何实现从右到左的顺序组合函数的呢？")]),s("p",[s("strong",[e._v("别慌我们来慢慢捋一下：")])]),s("p",[e._v("当funcs = [ f1, f2] 的时候，最终返回的结果是：(...args) => f1(f2(...args)。")]),s("p",[e._v("当funcs = [ f1, f2, f3] 的时候，\n首次执行reducer\na = f1, b = f2,\n分别用f1、f2 替换a、b得到")]),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   (...args) => a(b(...args))    \n=  (...args) => f1(f2(...args))\n")])]),s("p",[e._v("reducer执行第二次的时候，此时a为第一次执行reducer返回的结果\na = (...args) => f1(f2(...args)， b = f3，\n我们依旧分别用(...args) => f1(f2(...args)、f3 替换a、b得到\n(...args) => a(b(...args))"),s("br"),e._v("\n=  (...args) => a(f3(...args)"),s("br"),e._v("\n=  (...args) => f1(f2(f3(...args)))")]),s("p",[e._v("因此reducer执行第二次后返回的结果是(...args) =>f1(f2(f3(...args))), 与我们期望的结果相符。")]),s("p",[e._v("funcs.length > 3 的时候依此类推。")]),s("blockquote",[s("p",[e._v("是不是很熟悉？像不像递归？")])])])}],!1,null,null,null);r.default=n.exports}}]);